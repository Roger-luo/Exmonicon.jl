import{_ as e,c as t,o as a,a as n}from"./app.c2223259.js";const y=JSON.parse(`{"title":"Algebra data type","description":"","frontmatter":{},"headers":[{"level":2,"title":"Features","slug":"features","link":"#features","children":[]},{"level":2,"title":"Limitations","slug":"limitations","link":"#limitations","children":[]},{"level":2,"title":"What's happening under the hood","slug":"what-s-happening-under-the-hood","link":"#what-s-happening-under-the-hood","children":[]}],"relativePath":"intro/adts/intro.md","lastUpdated":1671084442000}`),i={name:"intro/adts/intro.md"},r=n('<h1 id="algebra-data-type" tabindex="-1">Algebra data type <a class="header-anchor" href="#algebra-data-type" aria-hidden="true">#</a></h1><p>Expronicon provides a way to define algebra data types. The syntax and semantic is very similar to rust&#39;s enum type. The algebra data type is useful when you want to define an intermediate representation (IR) for your own language, or when you want to define a type that can be used in a pattern matching.</p><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-hidden="true">#</a></h2><ul><li>support <code>MLStyle</code> pattern matching</li><li>type stable - this enables fast pattern matching and code manipulation</li><li>rust-like syntax</li></ul><h2 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-hidden="true">#</a></h2><p><strong>no support for generics</strong>, because we want to guarantee the type stability. For generic algebra data type, you can use the <code>@datatype</code> macro provided by MLStyle.</p><h2 id="what-s-happening-under-the-hood" tabindex="-1">What&#39;s happening under the hood <a class="header-anchor" href="#what-s-happening-under-the-hood" aria-hidden="true">#</a></h2><p>The <code>@adt</code> macro will generate a new type and a set of constructors for the type. It will wrap mulitple variants in the same Julia struct, and use a tag field to distinguish the variants. This is why it is type stable.</p><p>The <code>@adt</code> macro will also generate a set of functions for pattern matching too, which is why all <code>MLStyle</code> pattern matching works.</p><p>The <code>@adt</code> macro will also generate a set of reflection functions, so that you can inspect the algebra data type easily.</p>',10),o=[r];function s(d,h,l,c,p,u){return a(),t("div",null,o)}const f=e(i,[["render",s]]);export{y as __pageData,f as default};
